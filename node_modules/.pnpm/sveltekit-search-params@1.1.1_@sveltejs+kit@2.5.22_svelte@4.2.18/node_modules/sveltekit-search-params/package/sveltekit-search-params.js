/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { browser } from '$app/environment';
import { goto } from '$app/navigation';
import { page } from '$app/stores';
import { derived, get } from 'svelte/store';
import { compressToEncodedURIComponent, decompressFromEncodedURIComponent, } from './lz-string/index.js';
const GOTO_OPTIONS = {
    keepFocus: true,
    noScroll: true,
    replaceState: true,
};
const GOTO_OPTIONS_PUSH = {
    keepFocus: true,
    noScroll: true,
    replaceState: false,
};
function mixSearchAndOptions(searchParams, options) {
    const uniqueKeys = Array.from(new Set(Array.from(searchParams?.keys?.() || []).concat(Object.keys(options ?? {}))));
    let anyDefaultedParam = false;
    return [
        Object.fromEntries(uniqueKeys.map((key) => {
            let fnToCall = (value) => value;
            const optionsKey = options?.[key];
            if (typeof optionsKey !== 'boolean' &&
                typeof optionsKey?.decode === 'function') {
                fnToCall = optionsKey.decode;
            }
            const value = searchParams?.get(key);
            let actualValue;
            if (value == undefined &&
                optionsKey?.defaultValue != undefined) {
                actualValue = optionsKey.defaultValue;
                anyDefaultedParam = true;
            }
            else {
                actualValue = fnToCall(value);
            }
            return [key, actualValue];
        })),
        anyDefaultedParam,
    ];
}
export const ssp = {
    object: (defaultValue) => ({
        encode: (value) => JSON.stringify(value),
        decode: (value) => {
            if (value === null)
                return null;
            try {
                return JSON.parse(value);
            }
            catch (e) {
                return null;
            }
        },
        defaultValue,
    }),
    array: (defaultValue) => ({
        encode: (value) => JSON.stringify(value),
        decode: (value) => {
            if (value === null)
                return null;
            try {
                return JSON.parse(value);
            }
            catch (e) {
                return null;
            }
        },
        defaultValue,
    }),
    number: (defaultValue) => ({
        encode: (value) => value.toString(),
        decode: (value) => (value ? parseFloat(value) : null),
        defaultValue,
    }),
    boolean: (defaultValue) => ({
        encode: (value) => value + '',
        decode: (value) => value !== null && value !== 'false',
        defaultValue,
    }),
    string: (defaultValue) => ({
        encode: (value) => value ?? '',
        decode: (value) => value,
        defaultValue,
    }),
    lz: (defaultValue) => ({
        encode: (value) => compressToEncodedURIComponent(JSON.stringify(value)),
        decode: (value) => {
            if (!value)
                return null;
            try {
                return JSON.parse(decompressFromEncodedURIComponent(value) ?? '');
            }
            catch (e) {
                return null;
            }
        },
        defaultValue,
    }),
};
const batchedUpdates = new Set();
let batchTimeout;
const debouncedTimeouts = new Map();
export function queryParameters(options, { debounceHistory = 0, pushHistory = true, sort = true } = {}) {
    function set(value) {
        if (!browser)
            return;
        const hash = window.location.hash;
        const query = new URLSearchParams(window.location.search);
        const toBatch = (query) => {
            for (const field of Object.keys(value)) {
                if (value[field] == undefined) {
                    query.delete(field);
                    continue;
                }
                let fnToCall = (value) => value.toString();
                const optionsKey = options?.[field];
                if (typeof optionsKey !== 'boolean' &&
                    typeof optionsKey?.encode === 'function') {
                    fnToCall = optionsKey.encode;
                }
                const newValue = fnToCall(value[field]);
                if (newValue == undefined) {
                    query.delete(field);
                }
                else {
                    query.set(field, newValue);
                }
            }
        };
        batchedUpdates.add(toBatch);
        clearTimeout(batchTimeout);
        batchTimeout = setTimeout(async () => {
            batchedUpdates.forEach((batched) => {
                batched(query);
            });
            clearTimeout(debouncedTimeouts.get('queryParameters'));
            if (browser) {
                if (sort) {
                    query.sort();
                }
                await goto(`?${query}${hash}`, GOTO_OPTIONS);
            }
            if (pushHistory && browser) {
                debouncedTimeouts.set('queryParameters', setTimeout(() => {
                    if (sort) {
                        query.sort();
                    }
                    goto(hash, GOTO_OPTIONS_PUSH);
                }, debounceHistory));
            }
            batchedUpdates.clear();
        });
    }
    const { subscribe } = derived(page, ($page) => {
        const [valueToSet, anyDefaultedParam] = mixSearchAndOptions($page?.url?.searchParams, options);
        if (anyDefaultedParam) {
            set(valueToSet);
        }
        return valueToSet;
    });
    return {
        set,
        subscribe,
        update: (updater) => {
            const currentValue = get({ subscribe });
            const newValue = updater(currentValue);
            set(newValue);
        },
    };
}
const DEFAULT_ENCODER_DECODER = {
    encode: (value) => value.toString(),
    decode: (value) => (value ? value.toString() : null),
};
export function queryParam(name, { encode: encode = DEFAULT_ENCODER_DECODER.encode, decode: decode = DEFAULT_ENCODER_DECODER.decode, defaultValue, } = DEFAULT_ENCODER_DECODER, { debounceHistory = 0, pushHistory = true, sort = true } = {}) {
    function set(value) {
        if (!browser)
            return;
        const hash = window.location.hash;
        const toBatch = (query) => {
            if (value == undefined) {
                query.delete(name);
            }
            else {
                const newValue = encode(value);
                if (newValue == undefined) {
                    query.delete(name);
                }
                else {
                    query.set(name, newValue);
                }
            }
        };
        batchedUpdates.add(toBatch);
        clearTimeout(batchTimeout);
        const query = new URLSearchParams(window.location.search);
        batchTimeout = setTimeout(async () => {
            batchedUpdates.forEach((batched) => {
                batched(query);
            });
            clearTimeout(debouncedTimeouts.get(name));
            if (browser) {
                if (sort) {
                    query.sort();
                }
                await goto(`?${query}${hash}`, GOTO_OPTIONS);
            }
            if (pushHistory && browser) {
                debouncedTimeouts.set(name, setTimeout(() => {
                    if (sort) {
                        query.sort();
                    }
                    goto(hash, GOTO_OPTIONS_PUSH);
                }, debounceHistory));
            }
            batchedUpdates.clear();
        });
    }
    const { subscribe } = derived(page, ($page) => {
        const actualParam = $page?.url?.searchParams?.get?.(name);
        if (actualParam == undefined && defaultValue != undefined) {
            set(defaultValue);
            return defaultValue;
        }
        return decode(actualParam);
    });
    return {
        set,
        subscribe,
        update: (updater) => {
            const currentValue = get({ subscribe });
            const newValue = updater(currentValue);
            set(newValue);
        },
    };
}
