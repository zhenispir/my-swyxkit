{
  "version": 3,
  "sources": ["../../.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/attributes/index.js", "../../.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/events/index.js", "../../.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/utils/index.js", "../../.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/internal/index.js", "../../.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/parameter/const.js", "../../.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/parameter/index.js", "../../.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/store/index.js", "../../.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/action/index.js"],
  "sourcesContent": ["/**\n * all relevant data attribute name literals\n * @internal\n */\nexport const ATTRIBUTES = {\n  // markers from `@svelte-put/preprocess-auo-slug`\n  autoslug: 'data-auto-slug',\n  autoSlugAnchor: 'data-auto-slug-anchor',\n  autoSlugAnchorPosition: 'data-auto-slug-anchor-position',\n  // markers\n  toc: 'data-toc',\n  anchor: 'data-toc-anchor',\n  root: 'data-toc-root',\n  // customization per matching element\n  id: 'data-toc-id',\n  ignore: 'data-toc-ignore',\n  strategy: 'data-toc-strategy',\n  threshold: 'data-toc-threshold',\n  // tracking information for `IntersectionObserver`\n  observeFor: 'data-toc-observe-for',\n  observeThrottled: 'data-toc-observe-throttled',\n  observeActiveId: 'data-toc-observe-active-id',\n  // for elements that `use:toclink`\n  linkFor: 'data-toc-link-for',\n  linkActive: 'data-toc-link-active',\n};\n", "/**\n * all relevant event name literals\n * @internal\n */\nconst EVENTS = {\n  init: 'tocinit',\n  change: 'tocchange',\n};\n\n/**\n * @internal\n * @param {HTMLElement} node\n * @param {import('./events').TocChangeEventDetail} detail\n * @returns {import('./events').TocChangeEventDetail}\n */\nexport function dispatchChange(node, detail) {\n  node.dispatchEvent(new CustomEvent(EVENTS.change, { detail }));\n  return detail;\n}\n\n/**\n * @internal\n * @param {HTMLElement} node\n * @param {import('./events').TocInitEventDetail} detail\n * @returns {import('./events').TocInitEventDetail}\n */\nexport function dispatchInit(node, detail) {\n  node.dispatchEvent(new CustomEvent(EVENTS.init, { detail }));\n  return detail;\n}\n\n/**\n * Deprecated, use `TocInitEventDetail` instead\n * @typedef {import('./events').TocInitEventDetail} TocInitEventDetails\n */\n\n/**\n * Deprecated, use `TocChangeEventDetail` instead\n * @typedef {import('./events').TocChangeEventDetail} TocChangeEventDetails\n */\n\n/**\n * Deprecated, use `TocEventDetail` instead\n * @typedef {import('./events').TocEventDetail} TocEventDetails\n */\n", "/**\n * Slugify a string\n *\n * @public\n *\n * @param {string} text - text to slugify\n * @returns {string}\n */\nexport function slugify(text) {\n  if (!text) return text;\n  return text\n    .trim()\n    .toLowerCase()\n    .replace(/[''\"]+/gi, '')\n    .replace(/[^a-z0-9\\-_]+/gi, '-')\n    .replace(/-+$/, '')\n    .replace(/^-+/, '')\n    .replace(/-+/g, '-');\n}\n", "import { ATTRIBUTES } from '../attributes/index.js';\nimport { slugify } from '../utils/index.js';\n/**\n * @internal\n * @type {Record<string, import('./internal').TocCacheItem>}\n */\nexport const cache = {};\n\n/**\n * @internal\n * @param {(activeTocItemId?: string) => void} callback\n * @returns {IntersectionObserverCallback}\n */\nexport function intersectionObserverCallback(callback) {\n  return (entries) => {\n    for (const entry of entries) {\n      const tocId = entry.target.getAttribute(ATTRIBUTES.observeFor);\n      if (tocId && entry.isIntersecting) {\n        callback(tocId);\n      }\n    }\n  };\n}\n\n/**\n * @internal\n * @param {HTMLElement} element\n * @returns {string}\n */\nexport function extractElementText(element) {\n  if (element.hasAttribute(ATTRIBUTES.autoslug)) {\n    // pre-processed by `@svelte-put/preprocess-auto-slug`\n    // must strip out `textContent` from any nested anchor element\n    return Array.from(element.childNodes).reduce((acc, child) => {\n      if (\n        child.nodeType !== Node.ELEMENT_NODE ||\n        !(/** @type {Element} */ (child).hasAttribute(ATTRIBUTES.autoSlugAnchor))\n      ) {\n        acc += child.textContent || '';\n      }\n      return acc;\n    }, '');\n  }\n  return element.textContent || '';\n}\n\n/**\n * @internal\n * @param {HTMLElement} element\n * @param {string} fallbackText\n * @returns {string}\n */\nexport function extractTocItemId(element, fallbackText) {\n  let tocId = element.id;\n  const dataTocId = element.getAttribute(ATTRIBUTES.id);\n  if (dataTocId) {\n    tocId = dataTocId;\n  } else if (!tocId) {\n    tocId = slugify(fallbackText.slice(0, 100));\n  }\n  return tocId;\n}\n\n/**\n * @internal\n * @param {HTMLElement} element\n * @param {import('../parameter/parameter').ResolvedTocConfig['scrollMarginTop']} scrollMarginTop\n * @returns {string}\n */\nexport function processScrollMarginTop(element, scrollMarginTop) {\n  if (!scrollMarginTop) return '';\n  const r1 = typeof scrollMarginTop === 'function' ? scrollMarginTop(element) : scrollMarginTop;\n  if (!r1) return '';\n  const r2 = typeof r1 === 'number' ? `${r1}px` : r1;\n  if (r2) {\n    element.style.scrollMarginTop = r2;\n  }\n  return r2;\n}\n\n/**\n * @internal\n * @param {Element | null | undefined} element\n * @returns {boolean}\n */\nexport function isAutoSlugInjectedAnchor(element) {\n  if (!element) return false;\n  return element.tagName === 'A' && element.hasAttribute(ATTRIBUTES.autoSlugAnchor);\n}\n/**\n * @internal\n * @param {HTMLElement} element\n * @param {import('../parameter/parameter').ResolvedTocConfig['anchor']} anchor\n * @param {string} tocId\n * @returns {HTMLAnchorElement | undefined}\n */\nexport function processAnchor(element, anchor, tocId) {\n  /** @type {HTMLAnchorElement | undefined} */\n  let a = undefined;\n  if (anchor.enabled) {\n    // only handle anchor & DOM transformation if not already done\n    // by `@svelte-put/preprocess-auto-slug`\n    if (!element.hasAttribute(ATTRIBUTES.autoslug)) {\n      a = document.createElement('a');\n      for (const [key, value] of Object.entries(anchor.properties)) {\n        a.setAttribute(key, value);\n      }\n      a.href = typeof anchor.href === 'function' ? anchor.href(tocId) : `#${tocId}`;\n      a.textContent = anchor.content;\n      switch (anchor.position) {\n        case 'before':\n          element.parentNode?.insertBefore(a, element);\n          break;\n        case 'prepend':\n          element.insertBefore(a, element.firstChild);\n          break;\n        case 'wrap':\n          a.innerHTML = element.outerHTML;\n          element.parentNode?.replaceChild(a, element);\n          break;\n        case 'append':\n          element.appendChild(a);\n          break;\n        case 'after':\n          element.parentNode?.insertBefore(a, element.nextSibling);\n          break;\n      }\n      a.toggleAttribute(ATTRIBUTES.anchor, true);\n    } else {\n      // already processed by `@svelte-put/preprocess-auto-slug`\n      // search for the injected anchor element\n      const autoSlugAnchorPosition = element.getAttribute(ATTRIBUTES.autoSlugAnchorPosition);\n      if (autoSlugAnchorPosition) {\n        switch (autoSlugAnchorPosition) {\n          case 'before': {\n            const previousElement = element.previousElementSibling;\n            if (isAutoSlugInjectedAnchor(previousElement)) {\n              a = /** @type {HTMLAnchorElement} */ (previousElement);\n            }\n            break;\n          }\n          case 'prepend':\n          case 'append': {\n            a = /** @type {HTMLAnchorElement} */ (\n              element.querySelector(`a[${ATTRIBUTES.autoSlugAnchor}]`)\n            );\n            break;\n          }\n          case 'after': {\n            const nextElement = element.nextElementSibling;\n            if (isAutoSlugInjectedAnchor(nextElement)) {\n              a = /** @type {HTMLAnchorElement} */ (nextElement);\n            }\n            break;\n          }\n          case 'wrap': {\n            const parentElement = element.parentElement;\n            if (isAutoSlugInjectedAnchor(parentElement)) {\n              a = /** @type {HTMLAnchorElement} */ (parentElement);\n            }\n            break;\n          }\n        }\n      }\n\n      if (!a) {\n        const previousElement = element.previousElementSibling;\n        const nextElement = element.nextElementSibling;\n        const parentElement = element.parentElement;\n        if (isAutoSlugInjectedAnchor(previousElement)) {\n          a = /** @type {HTMLAnchorElement} */ (previousElement);\n        } else if (isAutoSlugInjectedAnchor(nextElement)) {\n          a = /** @type {HTMLAnchorElement} */ (nextElement);\n        } else if (isAutoSlugInjectedAnchor(parentElement)) {\n          a = /** @type {HTMLAnchorElement} */ (parentElement);\n        } else {\n          a = /** @type {HTMLAnchorElement} */ (\n            element.querySelector(`a[${ATTRIBUTES.autoSlugAnchor}]`)\n          );\n        }\n      }\n    }\n  }\n  return a;\n}\n\n/**\n * @internal\n * @param {HTMLElement} element\n * @param {import('../parameter/parameter').ResolvedTocConfig['observe']} observe\n * @param {string} tocId\n * @param {(activeTocItemId?: string) => void} updateActiveTocItem\n * @param {Record<number, IntersectionObserver>} observerPool\n * @returns {import('../action/action').TocItem['observe']}\n */\nexport function processObserve(element, observe, tocId, updateActiveTocItem, observerPool) {\n  if (!observe.enabled) return undefined;\n  const parentElement = element.parentElement;\n  /** @type {Exclude<import('../parameter/parameter').ResolvedTocConfig['observe']['strategy'], 'auto'>} */\n  let rStrategy;\n  const userDefinedStrategy =\n    /** @type {import('../parameter/parameter').ResolvedTocConfig['observe']['strategy']} */ (\n      element.getAttribute(ATTRIBUTES.strategy)\n    ) || observe.strategy;\n  if (typeof userDefinedStrategy !== 'number' && userDefinedStrategy !== 'auto') {\n    rStrategy = userDefinedStrategy;\n  } else if (parentElement && parentElement.offsetHeight / window.innerHeight < 0.8) {\n    rStrategy = 'parent';\n  } else {\n    rStrategy = 'self';\n  }\n  /** @type {HTMLElement} */\n  let nodeToObserve;\n  switch (rStrategy) {\n    case 'self':\n      nodeToObserve = element;\n      break;\n    case 'parent':\n      nodeToObserve = /** @type {HTMLElement */ (element.parentElement);\n      break;\n  }\n  /** @type {number} */\n  let threshold;\n  if (element.hasAttribute(ATTRIBUTES.threshold)) {\n    threshold = parseFloat(element.getAttribute(ATTRIBUTES.threshold) || '0');\n  } else {\n    threshold =\n      typeof observe.threshold === 'function' ? observe.threshold(element) : observe.threshold;\n  }\n  const { root, rootMargin } = observe;\n  nodeToObserve.setAttribute(ATTRIBUTES.observeFor, tocId);\n  /** @type {IntersectionObserver} */\n  let observer;\n  if (observerPool[threshold]) {\n    observer = observerPool[threshold];\n  } else {\n    observer = new IntersectionObserver(intersectionObserverCallback(updateActiveTocItem), {\n      threshold,\n      rootMargin,\n      root,\n    });\n    observerPool[threshold] = observer;\n  }\n  observer.observe(nodeToObserve);\n  return { strategy: rStrategy, observer, threshold, element: nodeToObserve };\n}\n\n/**\n * @internal\n * @param {HTMLElement} element\n * @param {string | undefined} tocId\n * @returns {Element | null}\n */\nexport function findTocRoot(element, tocId = undefined) {\n  if (tocId) return document.querySelector(`[${ATTRIBUTES.root}=\"${tocId}\"]`);\n  else return element.closest(`[${ATTRIBUTES.root}]`);\n}\n", "/**\n * The default {@link TocParameter} for `toc` action\n */\nexport const DEFAULT_TOC_PARAMETER = /** @satisfies {import('./parameter').TocParameter} */ ({\n  id: '',\n  selector: ':where(h1, h2, h3, h4, h5, h6)',\n  ignore: ['.toc-exclude'],\n  scrollMarginTop: 0,\n  anchor: {\n    enabled: true,\n    content: '#',\n    position: 'prepend',\n    properties: {\n      'aria-hidden': 'true',\n      tabindex: '-1',\n    },\n    href: (slug) => `#${slug}`,\n  },\n  observe: {\n    enabled: false,\n    strategy: 'auto',\n    threshold: (element) => Math.min((0.8 * window.innerHeight) / element.offsetHeight, 1),\n  },\n  store: undefined,\n});\n\n/**\n * The default {@link TocLinkParameter} for `toclink` action\n * @internal\n */\nexport const DEFAULT_TOC_LINK_PARAMETER =\n  /** @satisfies {import('./parameter').TocLinkParameter} */ ({\n    tocId: undefined,\n    tocItem: undefined,\n    observe: {\n      enabled: false,\n      throttleOnClick: 800,\n      attribute: ['data-toc-link-current'],\n    },\n    store: undefined,\n  });\n", "import { DEFAULT_TOC_LINK_PARAMETER, DEFAULT_TOC_PARAMETER } from './const.js';\n\n/**\n * @internal\n * resolve {@link TocParameter}\n * for internal usage within toc operations\n * @param {import('./parameter.js').TocParameter} param\n */\nexport function resolveTocConfig(param = {}) {\n  /** @type {string[]} */\n  let ignore = DEFAULT_TOC_PARAMETER.ignore;\n  if (param.ignore) {\n    ignore = Array.isArray(param.ignore) ? param.ignore : [param.ignore];\n  }\n  return {\n    id: param?.id ?? param?.store?.id() ?? crypto.randomUUID(),\n    selector: `${param.selector ?? DEFAULT_TOC_PARAMETER.selector}${ignore\n      .map((i) => `:not(${i})`)\n      .join('')}`,\n    scrollMarginTop: param.scrollMarginTop ?? DEFAULT_TOC_PARAMETER.scrollMarginTop,\n    anchor:\n      typeof param.anchor === 'undefined'\n        ? DEFAULT_TOC_PARAMETER.anchor\n        : typeof param.anchor === 'boolean'\n        ? { ...DEFAULT_TOC_PARAMETER.anchor, enabled: param.anchor }\n        : {\n            enabled: param.anchor.enabled ?? true,\n            position: param.anchor.position ?? DEFAULT_TOC_PARAMETER.anchor.position,\n            content: param.anchor.content ?? DEFAULT_TOC_PARAMETER.anchor.content,\n            properties: {\n              ...DEFAULT_TOC_PARAMETER.anchor.properties,\n              ...param.anchor.properties,\n            },\n            href: param.anchor.href ?? DEFAULT_TOC_PARAMETER.anchor.href,\n          },\n    observe:\n      typeof param.observe === 'undefined'\n        ? DEFAULT_TOC_PARAMETER.observe\n        : typeof param.observe === 'boolean'\n        ? { ...DEFAULT_TOC_PARAMETER.observe, enabled: param.observe }\n        : {\n            ...DEFAULT_TOC_PARAMETER.observe,\n            ...param.observe,\n            enabled: param.observe.enabled ?? true,\n            strategy: param.observe.strategy ?? DEFAULT_TOC_PARAMETER.observe.strategy,\n            threshold: param.observe.threshold ?? DEFAULT_TOC_PARAMETER.observe.threshold,\n          },\n    store: param.store,\n  };\n}\n\n/**\n * Compare two ResolvedTocConfig\n * @deprecated not necessary as dynamic update is not supported\n * @internal\n * @param {import('./parameter.js').ResolvedTocConfig} p1 first parameters object to compare\n * @param {import('./parameter.js').ResolvedTocConfig} p2 second parameters object to compare\n * @returns whether 2 parameters objects have the same properties\n */\nexport function compareTocParameters(p1, p2) {\n  return Object.keys(p1).every((key) => {\n    const typedKey = /** @type {keyof import('./parameter.js').ResolvedTocConfig} */ (key);\n    if (typedKey === 'anchor') {\n      return Object.keys(p1.anchor).every((anchorKey) => {\n        const typedAnchorKey =\n          /** @type {keyof import('./parameter.js').ResolvedTocConfig['anchor']} */ (anchorKey);\n        return p1.anchor[typedAnchorKey] === p2.anchor[typedAnchorKey];\n      });\n    }\n    if (typedKey === 'observe') {\n      return Object.keys(p1.observe).every((observeKey) => {\n        const typedObserveKey =\n          /** @type {keyof import('./parameter.js').ResolvedTocConfig['observe']}*/ (observeKey);\n        return p1.observe[typedObserveKey] === p2.observe[typedObserveKey];\n      });\n    }\n    return p1[typedKey] === p2[typedKey];\n  });\n}\n/**\n * @internal\n * resolve {@link TocLinkParameter} for internal usage within toc operations\n * @param {import('./parameter.js').TocLinkParameter} param\n */\nexport function resolveTocLinkConfig(param = {}) {\n  return {\n    ...DEFAULT_TOC_LINK_PARAMETER,\n    ...param,\n    observe:\n      typeof param.observe === 'undefined'\n        ? DEFAULT_TOC_LINK_PARAMETER.observe\n        : typeof param.observe === 'boolean'\n        ? { ...DEFAULT_TOC_LINK_PARAMETER.observe, enabled: param.observe }\n        : {\n            enabled: param.observe.enabled ?? true,\n            attribute: resolveTocLinkObserveAttribute(param.observe.attribute),\n            throttleOnClick:\n              param.observe.throttleOnClick ?? DEFAULT_TOC_LINK_PARAMETER.observe.throttleOnClick,\n          },\n    store: param.store ?? DEFAULT_TOC_LINK_PARAMETER.store,\n  };\n}\n\n/**\n * @internal\n * @param {import('./parameter.js').TocLinkObserveConfig['attribute']} attribute | undefined\n * @returns {string[]}\n */\nfunction resolveTocLinkObserveAttribute(attribute) {\n  if (!attribute) return DEFAULT_TOC_LINK_PARAMETER.observe.attribute;\n  if (typeof attribute === 'boolean') return DEFAULT_TOC_LINK_PARAMETER.observe.attribute;\n  if (typeof attribute === 'string')\n    return [...DEFAULT_TOC_LINK_PARAMETER.observe.attribute, attribute];\n  return [...DEFAULT_TOC_LINK_PARAMETER.observe.attribute, ...attribute];\n}\n\n/**\n * @internal\n * @param {import('./parameter.js').TocLinkConfig} a\n * @param {import('./parameter.js').TocLinkConfig} b\n * @returns {boolean}\n */\nexport function compareTocLinkConfig(a, b) {\n  return a.store === b.store && JSON.stringify(a) === JSON.stringify(b);\n}\n\n/**\n * Deprecated, use `TocParameter` and `TocConfig` instead\n * @typedef {import('./parameter').TocConfig} TocParameters\n */\n\n/**\n * Deprecated, use `TocLinkParameter` and `TocLinkConfig` instead\n * @typedef {import('./parameter').TocLinkConfig} TocLinkParameters\n */\n", "import { writable } from 'svelte/store';\n\n/**\n * create a idiomatic svelte store to use with `toc` action\n * @public\n *\n * @example\n *\n * ```html\n * <script lang=\"ts\">\n *   import { toc, createTocStore  } from '@svelte-put/clickoutside';\n *\n *   const tocStore = createTocStore();\n *\n *   $: {\n *      const { activeItem, items } = $tocStore;\n *      console.log('all extracted toc items', items);\n *      console.log('activeItem', activeItem); // only if `observer: true`\n *   }\n * </script>\n *\n * <main use:toc={{ store: tocStore, observe: true }}>...</main\n * ```\n */\nexport function createTocStore() {\n  /** @type {string | undefined} */\n  let id = undefined;\n  /** @type {import('svelte/store').Writable<import('./store').TocStoreValue>} */\n  const { subscribe, set, update } = writable({\n    id,\n    items: {},\n    activeItem: undefined,\n  });\n  subscribe((state) => (id = state.id));\n  return {\n    subscribe,\n    set,\n    update,\n    id: () => id,\n  };\n}\n\n/**\n * @internal\n * @param {import('../parameter/parameter').ResolvedTocConfig['store']} store\n * @param {Partial<import('./store').TocStoreValue>} param1\n */\nexport function updateStore(store, { activeItem, id, items }) {\n  store?.update((state) => ({\n    ...state,\n    ...(activeItem && { activeItem }),\n    ...(id && { id }),\n    ...(items && { items }),\n  }));\n}\n", "import { tick } from 'svelte';\n\nimport { ATTRIBUTES } from '../attributes/index.js';\nimport { dispatchChange, dispatchInit } from '../events/index.js';\nimport {\n  cache,\n  extractElementText,\n  extractTocItemId,\n  findTocRoot,\n  processAnchor,\n  processObserve,\n  processScrollMarginTop,\n} from '../internal/index.js';\nimport { DEFAULT_TOC_LINK_PARAMETER } from '../parameter/const.js';\nimport {\n  resolveTocConfig,\n  resolveTocLinkConfig,\n  compareTocLinkConfig,\n} from '../parameter/index.js';\nimport { updateStore } from '../store/index.js';\n\n/**\n * search for matching elements, inject anchor element, watch for active element\n * in viewport with `IntersectionObserver`. All for building table of contents.\n *\n * For comprehensive documentation, see {@link https://svelte-put.vnphanquang.com/docs/toc | docs site }\n *\n * @public\n *\n * @remarks\n *\n * As with any svelte action, `clickoutside` should be use with element and not component.\n *\n * ```html\n * <-- correct usage-->\n *  <div use:toc />\n *\n * <-- incorrect usage-->\n * <Component use:toc/>\n * ```\n *\n * @example\n *\n * Minimal use with idiomatic svelte store\n *\n * ```html\n * <script lang=\"ts\">\n *   import { toc, createTocStore  } from '@svelte-put/clickoutside';\n *\n *   const tocStore = createTocStore();\n *\n *   $: {\n *      const { activeItem, items } = $tocStore;\n *      console.log('all extracted toc items', items);\n *      console.log('activeItem', activeItem); // only if `observer: true`\n *   }\n * </script>\n *\n * <main use:toc={{ store: tocStore, observe: true }}>\n *   <h1>Page heading</h1>\n *   <section>\n *     <h2>Section heading</h2>\n *   </section>\n *   ...\n * </main>\n * ```\n *\n * @example\n *\n * Usage with callbacks (alternative to svelte store)\n *\n * ```html\n * <script lang=\"ts\">\n *   import { toc } from '@svelte-put/clickoutside';\n *   import type { TocInitEventDetails, TocChangeEventDetails } from '@svelte-put/clickoutside';\n *\n *   function handleTocInit(event: CustomEvent<TocInitEventDetails>) {\n *      const { items } = event.detail;\n *   }\n *\n *   function handleTocChange(event: CustomEvent<TocChangeEventDetails>) {\n *      const { activeItem } = event.detail;\n *   }\n * </script>\n *\n * <main use:toc={{ observe: true }} on:tocinit={handleTocInit} on:tocchange={handleTocChange}>\n *  ...\n * </main>\n * ```\n *\n * @param {HTMLElement} node - root node to search for matching elements in descendants\n * @param {import('../parameter/parameter').TocParameter} param - instructions for `toc` behavior\n * @returns {import('./action').TocActionReturn}\n */\nexport function toc(node, param = {}) {\n  let resolved = resolveTocConfig(param);\n\n  // stay minimal by reusing as few `IntersectionObserver` as possible\n  // only create new `IntersectionObserver` for each new `threshold`\n  /** @type {Record<number, IntersectionObserver>} */\n  const intersectionObservers = {};\n  /** @type {MutationObserver} */\n  let mutationObserver;\n\n  function change(activeTocItemId = '') {\n    if (!cache[resolved.id].observeThrottled) {\n      node.setAttribute(ATTRIBUTES.observeActiveId, activeTocItemId);\n    }\n  }\n\n  /** @type {ReturnType<typeof setTimeout>} */\n  let tocObserveThrottleTimeoutId;\n  function observeActiveIdAttribute() {\n    mutationObserver = new MutationObserver((mutationList) => {\n      if (!node.isConnected) return;\n      for (const mutation of mutationList) {\n        if (mutation.type === 'attributes') {\n          switch (mutation.attributeName) {\n            case ATTRIBUTES.observeActiveId: {\n              const activeTocItemId = /** @type {HTMLElement} */ (mutation.target).getAttribute(\n                ATTRIBUTES.observeActiveId,\n              );\n              const cached = cache[resolved.id];\n              if (activeTocItemId && activeTocItemId !== cached.activeTocItemId) {\n                cached.activeTocItemId = activeTocItemId;\n                const activeItem = cached.items[activeTocItemId];\n                if (activeItem) {\n                  const detail = dispatchChange(node, {\n                    activeItem,\n                    id: resolved.id,\n                    items: cached.items,\n                  });\n                  updateStore(resolved.store, detail);\n                }\n              }\n              break;\n            }\n            case ATTRIBUTES.observeThrottled: {\n              const throttled = /** @type {HTMLElement} */ (mutation.target).getAttribute(\n                ATTRIBUTES.observeThrottled,\n              );\n              const cached = cache[resolved.id];\n              if (!cached.observeThrottled && throttled) {\n                cached.observeThrottled = true;\n                clearTimeout(tocObserveThrottleTimeoutId);\n                let ms = parseInt(throttled);\n                if (Number.isNaN(ms)) ms = DEFAULT_TOC_LINK_PARAMETER.observe.throttleOnClick;\n                tocObserveThrottleTimeoutId = setTimeout(() => {\n                  cached.observeThrottled = false;\n                  node.toggleAttribute(ATTRIBUTES.observeThrottled, false);\n                }, ms);\n              }\n              break;\n            }\n          }\n        }\n      }\n    });\n    mutationObserver.observe(node, {\n      attributes: true,\n      attributeFilter: [ATTRIBUTES.observeActiveId, ATTRIBUTES.observeThrottled],\n    });\n  }\n\n  tick().then(async () => {\n    const { id, selector, anchor, observe, scrollMarginTop } = resolved;\n    /** @type {HTMLElement[]} */\n    const elements = Array.from(node.querySelectorAll(selector));\n    /** @type {Promise<import('./action').TocItem['observe']>[]} */\n    const observePromises = [];\n\n    /** @type {import('../internal/internal').TocCacheItem} */\n    const cached = {\n      config: resolved,\n      items: {},\n      activeTocItemId: '',\n      observeThrottled: false,\n    };\n    cache[id] = cached;\n    node.setAttribute(ATTRIBUTES.observeActiveId, '');\n    for (const element of elements) {\n      if (element.hasAttribute(ATTRIBUTES.ignore)) continue;\n\n      const text = extractElementText(element);\n\n      const tocId = extractTocItemId(element, text);\n      element.id = tocId;\n\n      processScrollMarginTop(element, scrollMarginTop);\n      const a = processAnchor(element, anchor, tocId);\n\n      cached.items[tocId] = { element, id: tocId, text, anchor: a };\n\n      if (observe.enabled) {\n        // process observe async to avoid blocking main thread,\n        // which should be prioritized for rendering initial TOC\n        observePromises.push(\n          new Promise((resolve) => {\n            const rObserve = processObserve(element, observe, tocId, change, intersectionObservers);\n            cached.items[tocId].observe = rObserve;\n            resolve(rObserve);\n          }),\n        );\n      }\n\n      // mark that this element has been processed by `toc`\n      element.toggleAttribute(ATTRIBUTES.toc, true);\n    }\n\n    const detail = dispatchInit(node, { id, items: cached.items });\n    updateStore(resolved.store, detail);\n    if (observePromises.length) {\n      Promise.all(observePromises).then(() => {\n        observeActiveIdAttribute();\n        change(cached.activeTocItemId);\n      });\n    }\n\n    // mark this element as toc root\n    node.setAttribute(ATTRIBUTES.root, id);\n  });\n\n  return {\n    update(update) {\n      resolved = resolveTocConfig(update);\n      // right now `toc` does not support dynamic parameter updates\n      // meaning it'll only run once on component initialization\n      // and not on subsequent updates\n      // this is because the effort to support dynamic updates is rather high:\n      // - revert all previous operation (or detect which ones are still valid/invalid)\n      // - re-run operations\n    },\n    destroy() {\n      mutationObserver?.disconnect();\n      for (const observer of Object.values(intersectionObservers)) {\n        observer.disconnect();\n      }\n      clearTimeout(tocObserveThrottleTimeoutId);\n    },\n  };\n}\n\n/**\n * @public\n * complementary action to `use:toc` applies to anchor elements\n * that will link to a matching toc item on `click`\n *\n * See example for the functionalities this action provides\n *\n * @example\n *\n * `toclink` will do the following:\n *\n * 1. add `href` attribute in the form of `#${tocItem.id}` if not already\n *\n * 2. add `textContent` from `tocItem.text` if not already\n *\n * 3. add click event listener that will throttle `toc` observe,\n * customizable through `observe.throttleOnClick`\n *\n * 4. update `data-toc-link-active` attribute when the linked `tocItem` is active,\n * customizable through `observe.attribute`.\n *\n * ```html\n * <script>\n *   import { toc, toclink, createTocStore } from '@svelte-put/toc';\n *   const tocStore = createTocStore();\n * </script>\n *\n * <main use:toc={{ store: tocStore, observe: true }}>\n *   ...\n *   {#if Object.values($tocStore.items).length}\n *    <ul>\n *      {#each Object.values($tocStore.items) as tocItem}\n *        <li>\n *          <!-- svelte-ignore a11y-missing-attribute -->\n *          <a use:toclink={{\n *            tocItem,\n *            store: tocStore,\n *            observe: {\n *              attribute: ['aria-current', 'data-active'],\n *              throttleOnClick: 1000,\n *            },\n *          }}></a>\n *        </li>\n *      {/each}\n *    </ul>\n *   {/if}\n *   ...\n * </main>\n * ```\n * @param {HTMLAnchorElement} node\n * @param {import('../parameter/parameter').TocLinkParameter} param\n * @returns {import('./action').TocLinkActionReturn}\n */\nexport function toclink(node, param = {}) {\n  // initial safe keep\n  const initialHref = node.href;\n  const initialTextContent = node.textContent;\n\n  let resolved = resolveTocLinkConfig(param);\n  /** @type {Element | null} */\n  let tocRoot = null;\n  /** @type {string} */\n  let tocItemId;\n  /** @type {import('svelte/store').Unsubscriber} */\n  let storeUnsubscribe;\n  /** @type {MutationObserver} */\n  let mutationObserver;\n\n  function handleClick() {\n    if (tocRoot && tocItemId) {\n      tocRoot.setAttribute(\n        ATTRIBUTES.observeThrottled,\n        resolved.observe.throttleOnClick.toString(),\n      );\n      tocRoot.setAttribute(ATTRIBUTES.observeActiveId, tocItemId);\n    }\n  }\n\n  /**\n   * @param {boolean} current\n   */\n  function updateCurrent(current) {\n    for (const attribute of resolved.observe.attribute) {\n      node.setAttribute(attribute, current.toString());\n    }\n  }\n\n  function resolveAttributes() {\n    tocItemId = node.href.split('#')[1] ?? '';\n    if (resolved.tocItem) {\n      tocItemId = typeof resolved.tocItem === 'string' ? resolved.tocItem : resolved.tocItem.id;\n      if (!initialHref) {\n        node.href = `#${tocItemId}`;\n      }\n      if (!initialTextContent && typeof resolved.tocItem !== 'string') {\n        node.textContent = resolved.tocItem.text;\n      }\n    }\n    node.setAttribute(ATTRIBUTES.linkFor, tocItemId);\n  }\n\n  function execute() {\n    resolveAttributes();\n\n    tocRoot = findTocRoot(node, resolved.tocId ?? resolved.store?.id());\n    if (!tocRoot || !resolved.observe.enabled) return;\n    if (resolved.observe.throttleOnClick) {\n      node.addEventListener('click', handleClick);\n    }\n    if (resolved.observe.attribute.length) {\n      if (resolved.store) {\n        storeUnsubscribe = resolved.store.subscribe(({ activeItem }) => {\n          updateCurrent(activeItem?.id === tocItemId);\n        });\n      } else {\n        mutationObserver = new MutationObserver((mutationList) => {\n          for (const mutation of mutationList) {\n            if (\n              mutation.type === 'attributes' &&\n              mutation.attributeName === ATTRIBUTES.observeActiveId\n            ) {\n              const currentTocId = /** @type {HTMLElement} */ (mutation.target).getAttribute(\n                ATTRIBUTES.observeActiveId,\n              );\n              updateCurrent(currentTocId === tocItemId);\n            }\n          }\n        });\n        mutationObserver.observe(tocRoot, {\n          attributes: true,\n          attributeFilter: [ATTRIBUTES.observeActiveId],\n        });\n      }\n    }\n  }\n\n  function cleanup() {\n    mutationObserver?.disconnect();\n    node.removeEventListener('click', handleClick);\n    storeUnsubscribe?.();\n    updateCurrent(false);\n  }\n\n  execute();\n\n  return {\n    update(update = {}) {\n      if (!compareTocLinkConfig(param, update)) {\n        cleanup();\n        param = update;\n        resolved = resolveTocLinkConfig(param);\n        resolveAttributes();\n        execute();\n      }\n      tocRoot = findTocRoot(node, resolved.tocId ?? resolved.store?.id());\n    },\n    destroy() {\n      cleanup();\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
