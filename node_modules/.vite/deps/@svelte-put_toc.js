import "./chunk-P4NAGDUV.js";
import {
  writable
} from "./chunk-QGNU4PKC.js";
import {
  tick
} from "./chunk-Q7DPDGSW.js";
import "./chunk-IBAQKBBN.js";
import "./chunk-V6TY7KAL.js";

// node_modules/.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/attributes/index.js
var ATTRIBUTES = {
  // markers from `@svelte-put/preprocess-auo-slug`
  autoslug: "data-auto-slug",
  autoSlugAnchor: "data-auto-slug-anchor",
  autoSlugAnchorPosition: "data-auto-slug-anchor-position",
  // markers
  toc: "data-toc",
  anchor: "data-toc-anchor",
  root: "data-toc-root",
  // customization per matching element
  id: "data-toc-id",
  ignore: "data-toc-ignore",
  strategy: "data-toc-strategy",
  threshold: "data-toc-threshold",
  // tracking information for `IntersectionObserver`
  observeFor: "data-toc-observe-for",
  observeThrottled: "data-toc-observe-throttled",
  observeActiveId: "data-toc-observe-active-id",
  // for elements that `use:toclink`
  linkFor: "data-toc-link-for",
  linkActive: "data-toc-link-active"
};

// node_modules/.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/events/index.js
var EVENTS = {
  init: "tocinit",
  change: "tocchange"
};
function dispatchChange(node, detail) {
  node.dispatchEvent(new CustomEvent(EVENTS.change, { detail }));
  return detail;
}
function dispatchInit(node, detail) {
  node.dispatchEvent(new CustomEvent(EVENTS.init, { detail }));
  return detail;
}

// node_modules/.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/utils/index.js
function slugify(text) {
  if (!text) return text;
  return text.trim().toLowerCase().replace(/[''"]+/gi, "").replace(/[^a-z0-9\-_]+/gi, "-").replace(/-+$/, "").replace(/^-+/, "").replace(/-+/g, "-");
}

// node_modules/.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/internal/index.js
var cache = {};
function intersectionObserverCallback(callback) {
  return (entries) => {
    for (const entry of entries) {
      const tocId = entry.target.getAttribute(ATTRIBUTES.observeFor);
      if (tocId && entry.isIntersecting) {
        callback(tocId);
      }
    }
  };
}
function extractElementText(element) {
  if (element.hasAttribute(ATTRIBUTES.autoslug)) {
    return Array.from(element.childNodes).reduce((acc, child) => {
      if (child.nodeType !== Node.ELEMENT_NODE || !/** @type {Element} */
      child.hasAttribute(ATTRIBUTES.autoSlugAnchor)) {
        acc += child.textContent || "";
      }
      return acc;
    }, "");
  }
  return element.textContent || "";
}
function extractTocItemId(element, fallbackText) {
  let tocId = element.id;
  const dataTocId = element.getAttribute(ATTRIBUTES.id);
  if (dataTocId) {
    tocId = dataTocId;
  } else if (!tocId) {
    tocId = slugify(fallbackText.slice(0, 100));
  }
  return tocId;
}
function processScrollMarginTop(element, scrollMarginTop) {
  if (!scrollMarginTop) return "";
  const r1 = typeof scrollMarginTop === "function" ? scrollMarginTop(element) : scrollMarginTop;
  if (!r1) return "";
  const r2 = typeof r1 === "number" ? `${r1}px` : r1;
  if (r2) {
    element.style.scrollMarginTop = r2;
  }
  return r2;
}
function isAutoSlugInjectedAnchor(element) {
  if (!element) return false;
  return element.tagName === "A" && element.hasAttribute(ATTRIBUTES.autoSlugAnchor);
}
function processAnchor(element, anchor, tocId) {
  var _a, _b, _c;
  let a = void 0;
  if (anchor.enabled) {
    if (!element.hasAttribute(ATTRIBUTES.autoslug)) {
      a = document.createElement("a");
      for (const [key, value] of Object.entries(anchor.properties)) {
        a.setAttribute(key, value);
      }
      a.href = typeof anchor.href === "function" ? anchor.href(tocId) : `#${tocId}`;
      a.textContent = anchor.content;
      switch (anchor.position) {
        case "before":
          (_a = element.parentNode) == null ? void 0 : _a.insertBefore(a, element);
          break;
        case "prepend":
          element.insertBefore(a, element.firstChild);
          break;
        case "wrap":
          a.innerHTML = element.outerHTML;
          (_b = element.parentNode) == null ? void 0 : _b.replaceChild(a, element);
          break;
        case "append":
          element.appendChild(a);
          break;
        case "after":
          (_c = element.parentNode) == null ? void 0 : _c.insertBefore(a, element.nextSibling);
          break;
      }
      a.toggleAttribute(ATTRIBUTES.anchor, true);
    } else {
      const autoSlugAnchorPosition = element.getAttribute(ATTRIBUTES.autoSlugAnchorPosition);
      if (autoSlugAnchorPosition) {
        switch (autoSlugAnchorPosition) {
          case "before": {
            const previousElement = element.previousElementSibling;
            if (isAutoSlugInjectedAnchor(previousElement)) {
              a = /** @type {HTMLAnchorElement} */
              previousElement;
            }
            break;
          }
          case "prepend":
          case "append": {
            a = /** @type {HTMLAnchorElement} */
            element.querySelector(`a[${ATTRIBUTES.autoSlugAnchor}]`);
            break;
          }
          case "after": {
            const nextElement = element.nextElementSibling;
            if (isAutoSlugInjectedAnchor(nextElement)) {
              a = /** @type {HTMLAnchorElement} */
              nextElement;
            }
            break;
          }
          case "wrap": {
            const parentElement = element.parentElement;
            if (isAutoSlugInjectedAnchor(parentElement)) {
              a = /** @type {HTMLAnchorElement} */
              parentElement;
            }
            break;
          }
        }
      }
      if (!a) {
        const previousElement = element.previousElementSibling;
        const nextElement = element.nextElementSibling;
        const parentElement = element.parentElement;
        if (isAutoSlugInjectedAnchor(previousElement)) {
          a = /** @type {HTMLAnchorElement} */
          previousElement;
        } else if (isAutoSlugInjectedAnchor(nextElement)) {
          a = /** @type {HTMLAnchorElement} */
          nextElement;
        } else if (isAutoSlugInjectedAnchor(parentElement)) {
          a = /** @type {HTMLAnchorElement} */
          parentElement;
        } else {
          a = /** @type {HTMLAnchorElement} */
          element.querySelector(`a[${ATTRIBUTES.autoSlugAnchor}]`);
        }
      }
    }
  }
  return a;
}
function processObserve(element, observe, tocId, updateActiveTocItem, observerPool) {
  if (!observe.enabled) return void 0;
  const parentElement = element.parentElement;
  let rStrategy;
  const userDefinedStrategy = (
    /** @type {import('../parameter/parameter').ResolvedTocConfig['observe']['strategy']} */
    element.getAttribute(ATTRIBUTES.strategy) || observe.strategy
  );
  if (typeof userDefinedStrategy !== "number" && userDefinedStrategy !== "auto") {
    rStrategy = userDefinedStrategy;
  } else if (parentElement && parentElement.offsetHeight / window.innerHeight < 0.8) {
    rStrategy = "parent";
  } else {
    rStrategy = "self";
  }
  let nodeToObserve;
  switch (rStrategy) {
    case "self":
      nodeToObserve = element;
      break;
    case "parent":
      nodeToObserve = /** @type {HTMLElement */
      element.parentElement;
      break;
  }
  let threshold;
  if (element.hasAttribute(ATTRIBUTES.threshold)) {
    threshold = parseFloat(element.getAttribute(ATTRIBUTES.threshold) || "0");
  } else {
    threshold = typeof observe.threshold === "function" ? observe.threshold(element) : observe.threshold;
  }
  const { root, rootMargin } = observe;
  nodeToObserve.setAttribute(ATTRIBUTES.observeFor, tocId);
  let observer;
  if (observerPool[threshold]) {
    observer = observerPool[threshold];
  } else {
    observer = new IntersectionObserver(intersectionObserverCallback(updateActiveTocItem), {
      threshold,
      rootMargin,
      root
    });
    observerPool[threshold] = observer;
  }
  observer.observe(nodeToObserve);
  return { strategy: rStrategy, observer, threshold, element: nodeToObserve };
}
function findTocRoot(element, tocId = void 0) {
  if (tocId) return document.querySelector(`[${ATTRIBUTES.root}="${tocId}"]`);
  else return element.closest(`[${ATTRIBUTES.root}]`);
}

// node_modules/.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/parameter/const.js
var DEFAULT_TOC_PARAMETER = (
  /** @satisfies {import('./parameter').TocParameter} */
  {
    id: "",
    selector: ":where(h1, h2, h3, h4, h5, h6)",
    ignore: [".toc-exclude"],
    scrollMarginTop: 0,
    anchor: {
      enabled: true,
      content: "#",
      position: "prepend",
      properties: {
        "aria-hidden": "true",
        tabindex: "-1"
      },
      href: (slug) => `#${slug}`
    },
    observe: {
      enabled: false,
      strategy: "auto",
      threshold: (element) => Math.min(0.8 * window.innerHeight / element.offsetHeight, 1)
    },
    store: void 0
  }
);
var DEFAULT_TOC_LINK_PARAMETER = (
  /** @satisfies {import('./parameter').TocLinkParameter} */
  {
    tocId: void 0,
    tocItem: void 0,
    observe: {
      enabled: false,
      throttleOnClick: 800,
      attribute: ["data-toc-link-current"]
    },
    store: void 0
  }
);

// node_modules/.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/parameter/index.js
function resolveTocConfig(param = {}) {
  var _a;
  let ignore = DEFAULT_TOC_PARAMETER.ignore;
  if (param.ignore) {
    ignore = Array.isArray(param.ignore) ? param.ignore : [param.ignore];
  }
  return {
    id: (param == null ? void 0 : param.id) ?? ((_a = param == null ? void 0 : param.store) == null ? void 0 : _a.id()) ?? crypto.randomUUID(),
    selector: `${param.selector ?? DEFAULT_TOC_PARAMETER.selector}${ignore.map((i) => `:not(${i})`).join("")}`,
    scrollMarginTop: param.scrollMarginTop ?? DEFAULT_TOC_PARAMETER.scrollMarginTop,
    anchor: typeof param.anchor === "undefined" ? DEFAULT_TOC_PARAMETER.anchor : typeof param.anchor === "boolean" ? { ...DEFAULT_TOC_PARAMETER.anchor, enabled: param.anchor } : {
      enabled: param.anchor.enabled ?? true,
      position: param.anchor.position ?? DEFAULT_TOC_PARAMETER.anchor.position,
      content: param.anchor.content ?? DEFAULT_TOC_PARAMETER.anchor.content,
      properties: {
        ...DEFAULT_TOC_PARAMETER.anchor.properties,
        ...param.anchor.properties
      },
      href: param.anchor.href ?? DEFAULT_TOC_PARAMETER.anchor.href
    },
    observe: typeof param.observe === "undefined" ? DEFAULT_TOC_PARAMETER.observe : typeof param.observe === "boolean" ? { ...DEFAULT_TOC_PARAMETER.observe, enabled: param.observe } : {
      ...DEFAULT_TOC_PARAMETER.observe,
      ...param.observe,
      enabled: param.observe.enabled ?? true,
      strategy: param.observe.strategy ?? DEFAULT_TOC_PARAMETER.observe.strategy,
      threshold: param.observe.threshold ?? DEFAULT_TOC_PARAMETER.observe.threshold
    },
    store: param.store
  };
}
function resolveTocLinkConfig(param = {}) {
  return {
    ...DEFAULT_TOC_LINK_PARAMETER,
    ...param,
    observe: typeof param.observe === "undefined" ? DEFAULT_TOC_LINK_PARAMETER.observe : typeof param.observe === "boolean" ? { ...DEFAULT_TOC_LINK_PARAMETER.observe, enabled: param.observe } : {
      enabled: param.observe.enabled ?? true,
      attribute: resolveTocLinkObserveAttribute(param.observe.attribute),
      throttleOnClick: param.observe.throttleOnClick ?? DEFAULT_TOC_LINK_PARAMETER.observe.throttleOnClick
    },
    store: param.store ?? DEFAULT_TOC_LINK_PARAMETER.store
  };
}
function resolveTocLinkObserveAttribute(attribute) {
  if (!attribute) return DEFAULT_TOC_LINK_PARAMETER.observe.attribute;
  if (typeof attribute === "boolean") return DEFAULT_TOC_LINK_PARAMETER.observe.attribute;
  if (typeof attribute === "string")
    return [...DEFAULT_TOC_LINK_PARAMETER.observe.attribute, attribute];
  return [...DEFAULT_TOC_LINK_PARAMETER.observe.attribute, ...attribute];
}
function compareTocLinkConfig(a, b) {
  return a.store === b.store && JSON.stringify(a) === JSON.stringify(b);
}

// node_modules/.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/store/index.js
function createTocStore() {
  let id = void 0;
  const { subscribe, set, update } = writable({
    id,
    items: {},
    activeItem: void 0
  });
  subscribe((state) => id = state.id);
  return {
    subscribe,
    set,
    update,
    id: () => id
  };
}
function updateStore(store, { activeItem, id, items }) {
  store == null ? void 0 : store.update((state) => ({
    ...state,
    ...activeItem && { activeItem },
    ...id && { id },
    ...items && { items }
  }));
}

// node_modules/.pnpm/@svelte-put+toc@4.0.0_svelte@4.2.18/node_modules/@svelte-put/toc/src/action/index.js
function toc(node, param = {}) {
  let resolved = resolveTocConfig(param);
  const intersectionObservers = {};
  let mutationObserver;
  function change(activeTocItemId = "") {
    if (!cache[resolved.id].observeThrottled) {
      node.setAttribute(ATTRIBUTES.observeActiveId, activeTocItemId);
    }
  }
  let tocObserveThrottleTimeoutId;
  function observeActiveIdAttribute() {
    mutationObserver = new MutationObserver((mutationList) => {
      if (!node.isConnected) return;
      for (const mutation of mutationList) {
        if (mutation.type === "attributes") {
          switch (mutation.attributeName) {
            case ATTRIBUTES.observeActiveId: {
              const activeTocItemId = (
                /** @type {HTMLElement} */
                mutation.target.getAttribute(
                  ATTRIBUTES.observeActiveId
                )
              );
              const cached = cache[resolved.id];
              if (activeTocItemId && activeTocItemId !== cached.activeTocItemId) {
                cached.activeTocItemId = activeTocItemId;
                const activeItem = cached.items[activeTocItemId];
                if (activeItem) {
                  const detail = dispatchChange(node, {
                    activeItem,
                    id: resolved.id,
                    items: cached.items
                  });
                  updateStore(resolved.store, detail);
                }
              }
              break;
            }
            case ATTRIBUTES.observeThrottled: {
              const throttled = (
                /** @type {HTMLElement} */
                mutation.target.getAttribute(
                  ATTRIBUTES.observeThrottled
                )
              );
              const cached = cache[resolved.id];
              if (!cached.observeThrottled && throttled) {
                cached.observeThrottled = true;
                clearTimeout(tocObserveThrottleTimeoutId);
                let ms = parseInt(throttled);
                if (Number.isNaN(ms)) ms = DEFAULT_TOC_LINK_PARAMETER.observe.throttleOnClick;
                tocObserveThrottleTimeoutId = setTimeout(() => {
                  cached.observeThrottled = false;
                  node.toggleAttribute(ATTRIBUTES.observeThrottled, false);
                }, ms);
              }
              break;
            }
          }
        }
      }
    });
    mutationObserver.observe(node, {
      attributes: true,
      attributeFilter: [ATTRIBUTES.observeActiveId, ATTRIBUTES.observeThrottled]
    });
  }
  tick().then(async () => {
    const { id, selector, anchor, observe, scrollMarginTop } = resolved;
    const elements = Array.from(node.querySelectorAll(selector));
    const observePromises = [];
    const cached = {
      config: resolved,
      items: {},
      activeTocItemId: "",
      observeThrottled: false
    };
    cache[id] = cached;
    node.setAttribute(ATTRIBUTES.observeActiveId, "");
    for (const element of elements) {
      if (element.hasAttribute(ATTRIBUTES.ignore)) continue;
      const text = extractElementText(element);
      const tocId = extractTocItemId(element, text);
      element.id = tocId;
      processScrollMarginTop(element, scrollMarginTop);
      const a = processAnchor(element, anchor, tocId);
      cached.items[tocId] = { element, id: tocId, text, anchor: a };
      if (observe.enabled) {
        observePromises.push(
          new Promise((resolve) => {
            const rObserve = processObserve(element, observe, tocId, change, intersectionObservers);
            cached.items[tocId].observe = rObserve;
            resolve(rObserve);
          })
        );
      }
      element.toggleAttribute(ATTRIBUTES.toc, true);
    }
    const detail = dispatchInit(node, { id, items: cached.items });
    updateStore(resolved.store, detail);
    if (observePromises.length) {
      Promise.all(observePromises).then(() => {
        observeActiveIdAttribute();
        change(cached.activeTocItemId);
      });
    }
    node.setAttribute(ATTRIBUTES.root, id);
  });
  return {
    update(update) {
      resolved = resolveTocConfig(update);
    },
    destroy() {
      mutationObserver == null ? void 0 : mutationObserver.disconnect();
      for (const observer of Object.values(intersectionObservers)) {
        observer.disconnect();
      }
      clearTimeout(tocObserveThrottleTimeoutId);
    }
  };
}
function toclink(node, param = {}) {
  const initialHref = node.href;
  const initialTextContent = node.textContent;
  let resolved = resolveTocLinkConfig(param);
  let tocRoot = null;
  let tocItemId;
  let storeUnsubscribe;
  let mutationObserver;
  function handleClick() {
    if (tocRoot && tocItemId) {
      tocRoot.setAttribute(
        ATTRIBUTES.observeThrottled,
        resolved.observe.throttleOnClick.toString()
      );
      tocRoot.setAttribute(ATTRIBUTES.observeActiveId, tocItemId);
    }
  }
  function updateCurrent(current) {
    for (const attribute of resolved.observe.attribute) {
      node.setAttribute(attribute, current.toString());
    }
  }
  function resolveAttributes() {
    tocItemId = node.href.split("#")[1] ?? "";
    if (resolved.tocItem) {
      tocItemId = typeof resolved.tocItem === "string" ? resolved.tocItem : resolved.tocItem.id;
      if (!initialHref) {
        node.href = `#${tocItemId}`;
      }
      if (!initialTextContent && typeof resolved.tocItem !== "string") {
        node.textContent = resolved.tocItem.text;
      }
    }
    node.setAttribute(ATTRIBUTES.linkFor, tocItemId);
  }
  function execute() {
    var _a;
    resolveAttributes();
    tocRoot = findTocRoot(node, resolved.tocId ?? ((_a = resolved.store) == null ? void 0 : _a.id()));
    if (!tocRoot || !resolved.observe.enabled) return;
    if (resolved.observe.throttleOnClick) {
      node.addEventListener("click", handleClick);
    }
    if (resolved.observe.attribute.length) {
      if (resolved.store) {
        storeUnsubscribe = resolved.store.subscribe(({ activeItem }) => {
          updateCurrent((activeItem == null ? void 0 : activeItem.id) === tocItemId);
        });
      } else {
        mutationObserver = new MutationObserver((mutationList) => {
          for (const mutation of mutationList) {
            if (mutation.type === "attributes" && mutation.attributeName === ATTRIBUTES.observeActiveId) {
              const currentTocId = (
                /** @type {HTMLElement} */
                mutation.target.getAttribute(
                  ATTRIBUTES.observeActiveId
                )
              );
              updateCurrent(currentTocId === tocItemId);
            }
          }
        });
        mutationObserver.observe(tocRoot, {
          attributes: true,
          attributeFilter: [ATTRIBUTES.observeActiveId]
        });
      }
    }
  }
  function cleanup() {
    mutationObserver == null ? void 0 : mutationObserver.disconnect();
    node.removeEventListener("click", handleClick);
    storeUnsubscribe == null ? void 0 : storeUnsubscribe();
    updateCurrent(false);
  }
  execute();
  return {
    update(update = {}) {
      var _a;
      if (!compareTocLinkConfig(param, update)) {
        cleanup();
        param = update;
        resolved = resolveTocLinkConfig(param);
        resolveAttributes();
        execute();
      }
      tocRoot = findTocRoot(node, resolved.tocId ?? ((_a = resolved.store) == null ? void 0 : _a.id()));
    },
    destroy() {
      cleanup();
    }
  };
}
export {
  createTocStore,
  toc,
  toclink
};
//# sourceMappingURL=@svelte-put_toc.js.map
